import numpy as np
import pandas as pd
import pandas_market_calendars as mcal
from typing import Tuple

def generate_paths(annual_mean: float, annual_std_dev: float, start_date: str, n_steps: int = 252, n_paths: int = 10000) -> pd.DataFrame:
    """
    Generate multiple paths assuming a normal distribution with compound returns.
    
    Parameters:
    annual_mean (float): Annualized mean return
    annual_std_dev (float): Annualized standard deviation of returns
    start_date (str): Start date in 'YYYY-MM-DD' format
    n_steps (int): Number of steps (trading days) to simulate
    n_paths (int): Number of paths to generate
    
    Returns:
    pd.DataFrame: DataFrame with dates as index and paths as columns
    """
    # Convert annual parameters to daily
    daily_mean = annual_mean / 252
    daily_std_dev = annual_std_dev / np.sqrt(252)

    # Generate random steps for all paths at once
    steps = np.random.normal(loc=daily_mean, scale=daily_std_dev, size=(n_paths, n_steps))
    
    # Calculate the cumulative sum of log returns
    log_returns = np.cumsum(steps, axis=1)
    
    # Convert log returns to actual returns
    paths = np.exp(log_returns) - 1
    
    # Add the initial point (0) to the beginning of each path
    paths = np.hstack((np.zeros((n_paths, 1)), paths))

    # Generate trading dates
    nyse = mcal.get_calendar('NYSE')
    start_date = pd.Timestamp(start_date)
    end_date = start_date + pd.Timedelta(days=n_steps * 2)  # Approximate to ensure we get enough trading days
    trading_dates = nyse.valid_days(start_date=start_date, end_date=end_date)[:n_steps+1]
    
    # Convert Timestamps to dates
    trading_dates = trading_dates.date

    # Create DataFrame with dates as index
    df_paths = pd.DataFrame(paths.T, index=trading_dates, columns=[f'path_{i}' for i in range(n_paths)])
    
    return df_paths

def get_percentile_paths(paths: pd.DataFrame, lower_percentile: float = 25, upper_percentile: float = 75) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """
    Calculate mean path and percentile paths from generated paths.
    
    Parameters:
    paths (pd.DataFrame): DataFrame of paths generated by generate_paths
    lower_percentile (float): Lower percentile (default 25)
    upper_percentile (float): Upper percentile (default 75)
    
    Returns:
    Tuple[pd.Series, pd.Series, pd.Series]: Mean path, lower percentile path, upper percentile path
    """
    mean_path = paths.mean(axis=1)
    lower_path = paths.quantile(lower_percentile/100, axis=1)
    upper_path = paths.quantile(upper_percentile/100, axis=1)
    
    return mean_path, lower_path, upper_path

def simulate_balance_paths(starting_balance: float, annual_mean: float, annual_std_dev: float, 
                           start_date: str, n_steps: int = 252, n_paths: int = 10000) -> dict:
    """
    Simulate balance paths based on given parameters.

    Parameters:
    starting_balance (float): Initial balance
    annual_mean (float): Annualized mean return
    annual_std_dev (float): Annualized standard deviation of returns
    start_date (str): Start date in 'YYYY-MM-DD' format
    n_steps (int): Number of steps (trading days) to simulate (default 252)
    n_paths (int): Number of paths to generate (default 10000)

    Returns:
    dict: A dictionary containing simulation results
    """
    # Generate paths
    paths = generate_paths(annual_mean, annual_std_dev, start_date, n_steps, n_paths)
    
    # Apply to starting balance
    balance_paths = starting_balance * (1 + paths)

    # Calculate 95th and 5th percentile paths
    percentile_95_path = balance_paths.quantile(0.95, axis=1)
    percentile_5_path = balance_paths.quantile(0.05, axis=1)

    # Calculate probabilities
    one_year_index = min(252, len(balance_paths) - 1)  # Ensure we don't go out of bounds
    one_year_balances = balance_paths.iloc[one_year_index]
    starting_balance_percentile = (one_year_balances < starting_balance).mean()
    prob_95_percentile = 0.95 - starting_balance_percentile
    prob_5_percentile = starting_balance_percentile - 0.05

    # Convert index to datetime for resampling
    balance_paths.index = pd.to_datetime(balance_paths.index)
    percentile_95_path.index = pd.to_datetime(percentile_95_path.index)
    percentile_5_path.index = pd.to_datetime(percentile_5_path.index)

    # Resample to monthly frequency
    balance_paths_monthly = balance_paths.resample('ME').last()
    percentile_95_path_monthly = percentile_95_path.resample('ME').last()
    percentile_5_path_monthly = percentile_5_path.resample('ME').last()

    # Add start_date and starting_balance as the first data point to monthly objects
    start_date_ts = pd.Timestamp(start_date)
    balance_paths_monthly = pd.concat([pd.DataFrame({col: starting_balance for col in balance_paths_monthly.columns}, index=[start_date_ts]), balance_paths_monthly])
    percentile_95_path_monthly = pd.concat([pd.Series({start_date_ts: starting_balance}), percentile_95_path_monthly])
    percentile_5_path_monthly = pd.concat([pd.Series({start_date_ts: starting_balance}), percentile_5_path_monthly])

    # Convert to strings
    balance_paths_monthly.index = balance_paths_monthly.index.strftime('%Y-%m-%d')
    percentile_95_path_monthly.index = percentile_95_path_monthly.index.strftime('%Y-%m-%d')
    percentile_5_path_monthly.index = percentile_5_path_monthly.index.strftime('%Y-%m-%d')

    # Extract dates from the index
    dates = balance_paths_monthly.index.tolist()

    result = {
        "balance_paths": balance_paths_monthly,
        "percentile_95_balance_path": percentile_95_path_monthly,
        "percentile_5_balance_path": percentile_5_path_monthly,
        "prob_95_percentile": prob_95_percentile,
        "prob_5_percentile": prob_5_percentile,
        "final_balance_min": balance_paths_monthly.iloc[-1].min(),
        "final_balance_max": balance_paths_monthly.iloc[-1].max(),
        "final_95_percentile_balance": percentile_95_path_monthly.iloc[-1],
        "final_5_percentile_balance": percentile_5_path_monthly.iloc[-1],
        "dates": dates
    }

    return result

# Example usage:
# starting_balance = 300000  # starting balance
# annual_mean = 0.19  # annual return
# annual_std_dev = 0.45  # annual standard deviation
# start_date = '2024-08-31'

# result = simulate_balance_paths(starting_balance, annual_mean, annual_std_dev, start_date)

# print(result)

# print(f"Starting balance: ${starting_balance:.2f}")
# print(f"Final balance range: ${result['final_balance_min']:.2f} to ${result['final_balance_max']:.2f}")
# print(f"Mean final balance: ${result['final_mean_balance']:.2f}")
# print(f"25th percentile final balance: ${result['final_lower_balance']:.2f}")
# print(f"75th percentile final balance: ${result['final_upper_balance']:.2f}")
# print(f"Shape of balance paths: {result['balance_paths'].shape}")
# print(f"Date range: {result['balance_paths'].index[0]} to {result['balance_paths'].index[-1]}")
