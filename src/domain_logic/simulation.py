import numpy as np
import pandas as pd
import pandas_market_calendars as mcal
from typing import Tuple

def generate_paths(annual_mean: float, annual_std_dev: float, start_date: str, n_steps: int = 252, n_paths: int = 10000) -> pd.DataFrame:
    """
    Generate multiple paths assuming a normal distribution with compound returns.
    
    Parameters:
    annual_mean (float): Annualized mean return
    annual_std_dev (float): Annualized standard deviation of returns
    start_date (str): Start date in 'YYYY-MM-DD' format
    n_steps (int): Number of steps (trading days) to simulate
    n_paths (int): Number of paths to generate
    
    Returns:
    pd.DataFrame: DataFrame with dates as index and paths as columns
    """
    # Convert annual parameters to daily
    daily_mean = annual_mean / 252
    daily_std_dev = annual_std_dev / np.sqrt(252)

    # Generate random steps for all paths at once
    steps = np.random.normal(loc=daily_mean, scale=daily_std_dev, size=(n_paths, n_steps))
    
    # Calculate the cumulative sum of log returns
    log_returns = np.cumsum(steps, axis=1)
    
    # Convert log returns to actual returns
    paths = np.exp(log_returns) - 1
    
    # Add the initial point (0) to the beginning of each path
    paths = np.hstack((np.zeros((n_paths, 1)), paths))

    # Generate trading dates
    nyse = mcal.get_calendar('NYSE')
    start_date = pd.Timestamp(start_date)
    end_date = start_date + pd.Timedelta(days=n_steps * 2)  # Approximate to ensure we get enough trading days
    trading_dates = nyse.valid_days(start_date=start_date, end_date=end_date)[:n_steps+1]
    
    # Convert Timestamps to dates
    trading_dates = trading_dates.date

    # Create DataFrame with dates as index
    df_paths = pd.DataFrame(paths.T, index=trading_dates, columns=[f'path_{i}' for i in range(n_paths)])
    
    return df_paths

def get_percentile_paths(paths: pd.DataFrame, lower_percentile: float = 25, upper_percentile: float = 75) -> Tuple[pd.Series, pd.Series, pd.Series]:
    """
    Calculate mean path and percentile paths from generated paths.
    
    Parameters:
    paths (pd.DataFrame): DataFrame of paths generated by generate_paths
    lower_percentile (float): Lower percentile (default 25)
    upper_percentile (float): Upper percentile (default 75)
    
    Returns:
    Tuple[pd.Series, pd.Series, pd.Series]: Mean path, lower percentile path, upper percentile path
    """
    mean_path = paths.mean(axis=1)
    lower_path = paths.quantile(lower_percentile/100, axis=1)
    upper_path = paths.quantile(upper_percentile/100, axis=1)
    
    return mean_path, lower_path, upper_path

def simulate_balance_paths(starting_balance: float, annual_mean: float, annual_std_dev: float, 
                           start_date: str, n_steps: int = 252, n_paths: int = 10000, 
                           lower_percentile: float = 25, upper_percentile: float = 75) -> dict:
    """
    Simulate balance paths based on given parameters.

    Parameters:
    starting_balance (float): Initial balance
    annual_mean (float): Annualized mean return
    annual_std_dev (float): Annualized standard deviation of returns
    start_date (str): Start date in 'YYYY-MM-DD' format
    n_steps (int): Number of steps (trading days) to simulate (default 252)
    n_paths (int): Number of paths to generate (default 10000)
    lower_percentile (float): Lower percentile for path calculation (default 25)
    upper_percentile (float): Upper percentile for path calculation (default 75)

    Returns:
    dict: A dictionary containing simulation results
    """
    # Generate paths
    paths = generate_paths(annual_mean, annual_std_dev, start_date, n_steps, n_paths)
    
    # Calculate percentile paths
    mean_path, lower_path, upper_path = get_percentile_paths(paths, lower_percentile, upper_percentile)
    
    # Apply to starting balance
    balance_paths = starting_balance * (1 + paths)
    mean_balance_path = starting_balance * (1 + mean_path)
    lower_balance_path = starting_balance * (1 + lower_path)
    upper_balance_path = starting_balance * (1 + upper_path)

    # Convert index to datetime for resampling
    balance_paths.index = pd.to_datetime(balance_paths.index)
    mean_balance_path.index = pd.to_datetime(mean_balance_path.index)
    lower_balance_path.index = pd.to_datetime(lower_balance_path.index)
    upper_balance_path.index = pd.to_datetime(upper_balance_path.index)

    # Resample to monthly frequency
    balance_paths_monthly = balance_paths.resample('ME').last()
    mean_balance_path_monthly = mean_balance_path.resample('ME').last()
    lower_balance_path_monthly = lower_balance_path.resample('ME').last()
    upper_balance_path_monthly = upper_balance_path.resample('ME').last()

    # Convert to strings
    balance_paths_monthly.index = balance_paths_monthly.index.strftime('%Y-%m-%d')
    mean_balance_path_monthly.index = mean_balance_path_monthly.index.strftime('%Y-%m-%d')
    lower_balance_path_monthly.index = lower_balance_path_monthly.index.strftime('%Y-%m-%d')
    upper_balance_path_monthly.index = upper_balance_path_monthly.index.strftime('%Y-%m-%d')

    # Extract dates from the index
    dates = balance_paths_monthly.index.tolist()

    result = {
        "balance_paths": balance_paths_monthly,
        "mean_balance_path": mean_balance_path_monthly,
        "lower_balance_path": lower_balance_path_monthly,
        "upper_balance_path": upper_balance_path_monthly,
        "final_balance_min": balance_paths_monthly.iloc[-1].min(),
        "final_balance_max": balance_paths_monthly.iloc[-1].max(),
        "final_mean_balance": mean_balance_path_monthly.iloc[-1],
        "final_lower_balance": lower_balance_path_monthly.iloc[-1],
        "final_upper_balance": upper_balance_path_monthly.iloc[-1],
        "dates": dates
    }

    return result

# Example usage:
# starting_balance = 300000  # starting balance
# annual_mean = 0.19  # annual return
# annual_std_dev = 0.45  # annual standard deviation
# start_date = '2023-01-01'

# result = simulate_balance_paths(starting_balance, annual_mean, annual_std_dev, start_date)

# print(f"Starting balance: ${starting_balance:.2f}")
# print(f"Final balance range: ${result['final_balance_min']:.2f} to ${result['final_balance_max']:.2f}")
# print(f"Mean final balance: ${result['final_mean_balance']:.2f}")
# print(f"25th percentile final balance: ${result['final_lower_balance']:.2f}")
# print(f"75th percentile final balance: ${result['final_upper_balance']:.2f}")
# print(f"Shape of balance paths: {result['balance_paths'].shape}")
# print(f"Date range: {result['balance_paths'].index[0]} to {result['balance_paths'].index[-1]}")
